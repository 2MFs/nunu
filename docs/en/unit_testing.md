## Documentation
* [User Guide](https://github.com/go-nunu/nunu/blob/main/docs/en/guide.md)
* [Architecture](https://github.com/go-nunu/nunu/blob/main/docs/en/architecture.md)
* [Getting Started Tutorial](https://github.com/go-nunu/nunu/blob/main/docs/en/tutorial.md)
* [Unit Testing](https://github.com/go-nunu/nunu/blob/main/docs/en/unit_testing.md)

[Go to Chinese version](https://github.com/go-nunu/nunu/blob/main/docs/zh/tutorial.md)

# Unit Testing

## Introduction

Performing unit testing in a project is an important development practice. However, writing unit tests becomes complex and unstable when the code under test depends on other modules or components. To address this issue, we can use mocks to simulate the dependencies of the code under test. By using mock objects, we can control the behavior of external modules, ensuring that the code under test does not actually depend on or invoke these external modules during testing, thus achieving isolation of the code under test. In Go language, we can use the golang/mock library to generate mock code, and use sqlmock and redismock to simulate the behavior of databases and caches. By using mocks, we can improve the reliability and efficiency of unit testing. This article will introduce how to write concise and efficient unit tests using mocks.

## Overview

First, let's take a look at the dependency injection file `cmd/server/wire.go` in the project:

> tip: This file is automatically compiled and generated by the `google/wire` tool, and manual editing is prohibited.

```
// Injectors from wire.go:

func newApp(viperViper *viper.Viper, logger *log.Logger) (*gin.Engine, func(), error) {
	jwt := middleware.NewJwt(viperViper)
	handlerHandler := handler.NewHandler(logger)
	sidSid := sid.NewSid()
	serviceService := service.NewService(logger, sidSid, jwt)
	db := repository.NewDB(viperViper)
	client := repository.NewRedis(viperViper)
	repositoryRepository := repository.NewRepository(db, client, logger)
	userRepository := repository.NewUserRepository(repositoryRepository)
	userService := service.NewUserService(serviceService, userRepository)
	userHandler := handler.NewUserHandler(handlerHandler, userService)
	engine := server.NewServerHTTP(logger, jwt, userHandler)
	return engine, func() {
	}, nil
}
```

From this code, we can see the dependency relationship between `repository`, `service`, and `handler`.

`userHandler` depends on `userService`, and `userService` depends on `userRepository`.

For example, the `GetProfile` code in `handler/user.go` is as follows:

```
func (h *userHandler) GetProfile(ctx *gin.Context) {
	userId := GetUserIdFromCtx(ctx)
	if userId == "" {
		resp.HandleError(ctx, http.StatusUnauthorized, 1, "unauthorized", nil)
		return
	}

	user, err := h.userService.GetProfile(ctx, userId)
	if err != nil {
		resp.HandleError(ctx, http.StatusBadRequest, 1, err.Error(), nil)
		return
	}

	resp.HandleSuccess(ctx, user)
}
```

We can see that it calls `userService.GetProfile` internally.

Therefore, when writing unit tests, we inevitably need to initialize the `userService` instance first. However, when we try to initialize `userService`, we find that it depends on `userRepository`.

Clearly, we only need to test the lowest level `handler`, but we need to initialize and execute code such as `service` and `repository` first. This obviously violates the principle of unit testing, where each unit test should focus on one functionality or code unit.

What is the better solution to this problem? Our final answer is `mock`.

### Mock (A Helper for Dependency Isolation)

When performing unit testing, we want to test the logic of the code unit under test, without relying on the state or behavior of other external modules or components. This approach can better isolate the code under test, making the testing more reliable and repeatable.

Mock is a testing pattern used to simulate or replace the external modules or components that the code under test depends on. By using mock objects, we can control the behavior of external modules, so that the code under test does not actually depend on or invoke these external modules during testing, thus achieving isolation of the code under test.

Mock objects can simulate the return values, exceptions, timeouts, etc. of external modules, making the testing more controllable and predictable. They solve the following problems:

1. Dependency on other modules: Some code units may depend on other modules, such as databases, network requests, etc. By using mock objects, we can simulate these dependencies, so that the testing does not need to actually depend on these modules, avoiding the instability and complexity of the testing.

2. Isolation of external environment: Some code units may be affected by the external environment, such as the current time, system status, etc. By using mock objects, we can control the state of these external environments, so that the testing can run in different environments, increasing the coverage and accuracy of the testing.

3. Improved testing efficiency: Some external modules may perform time-consuming operations, such as network requests, file I/O, etc. By using mock objects, we can avoid executing these operations, thus improving the execution speed and efficiency of the testing.

In the nunu project, we use the following mock libraries to help us write unit tests:

* github.com/golang/mock: A mock library open-sourced by Google.
* github.com/go-redis/redismock/v9: Provides mock testing for Redis queries, compatible with github.com/redis/go-redis/v9.
* github.com/DATA-DOG/go-sqlmock: sqlmock is a mock library that implements the sql/driver interface.

## Interface-Oriented Programming

To use `golang/mock`, there is a prerequisite that we need to follow the "interface-oriented programming" approach to write our `repository` and `service`.

Some of you may not be familiar with the term "interface-oriented programming". Let's take a code snippet as an example:

```go
package repository

import (
	"github.com/go-nunu/nunu-layout-advanced/internal/model"
)


type UserRepository interface {
	FirstById(id int64) (*model.User, error)
}
type userRepository struct {
	*Repository
}

func NewUserRepository(repository *Repository) *UserRepository {
	return &UserRepository{
		Repository: repository,
	}
}

func (r *UserRepository) FirstById(id int64) (*model.User, error) {
	var user model.User
	if err := r.db.Where("id = ?", id).First(&user).Error; err != nil {
		return nil, err
	}
	return &user, nil
}

```

In the above code, we first define a `UserRepository` interface, and then implement all its methods using the `userRepository` struct.
```
type UserRepository interface {
	FirstById(id int64) (*model.User, error)
}
type userRepository struct {
	*Repository
}
func (r *UserRepository) FirstById(id int64) (*model.User, error) {
    // ...
}

```
Instead of directly writing it as
```
type UserRepository struct {
	*Repository
}

func (r *UserRepository) FirstById(id int64) (*model.User, error) {
    // ...
}
```

This is called **interface-oriented programming**, which can improve the flexibility, scalability, testability, and maintainability of the code. It is a programming style highly advocated by the Go language.

## Getting Started with go-mock

Using `golang/mock` is actually simple. First, let's install it:

```
go install github.com/golang/mock/mockgen@v1.6.0
```

`mockgen` is a command-line tool of `go-mock` that can parse the interface definitions in our code and generate the correct mock code.

For example:
```
mockgen -source=internal/service/user.go -destination mocks/service/user.go
```

The above command specifies two parameters: the source file of the interface and the destination file where the mock code will be generated. We place the destination file in the `mocks/service` directory.

Once we have generated the mock code for `UserService`, we can proceed to write unit tests for `UserHandler`.

Here is the final unit test code:

```

func TestUserHandler_GetProfile(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockUserService := mock_service.NewMockUserService(ctrl)
	
	// Key code, define the return value of mockUserService.GetProfile
	mockUserService.EXPECT().GetProfile(gomock.Any(), userId).Return(&model.User{
		Id:       1,
		UserId:   userId,
		Username: "xxxxx",
		Nickname: "xxxxx",
		Password: "xxxxx",
		Email:    "xxxxx@gmail.com",
	}, nil)

	router := setupRouter(mockUserService)
	req, _ := http.NewRequest("GET", "/user", nil)
	req.Header.Set("Authorization", "Bearer "+token)
	resp := httptest.NewRecorder()

	router.ServeHTTP(resp, req)

	assert.Equal(t, resp.Code, http.StatusOK)
	// Add assertions for the response body if needed
}

```


The complete source code can be found at: https://github.com/go-nunu/nunu-layout-advanced/blob/main/test/server/handler/user_test.go

## sqlmock and redismock

For the unit testing of `repository`, which depends on external data sources such as RPC, Redis, and MySQL instead of our own business modules, we also perform mocking to avoid connecting to real databases and caches and reduce the uncertainty of testing.

The code is as follows:
```
package repository

import (
	"context"
	"testing"
	"time"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/go-nunu/nunu-layout-advanced/internal/model"
	"github.com/go-nunu/nunu-layout-advanced/internal/repository"
	"github.com/go-redis/redismock/v9"
	"github.com/stretchr/testify/assert"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
)

func setupRepository(t *testing.T) (repository.UserRepository, sqlmock.Sqlmock) {
	mockDB, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("failed to create sqlmock: %v", err)
	}

	db, err := gorm.Open(mysql.New(mysql.Config{
		Conn:                      mockDB,
		SkipInitializeWithVersion: true,
	}), &gorm.Config{})
	if err != nil {
		t.Fatalf("failed to open gorm connection: %v", err)
	}

	rdb, _ := redismock.NewClientMock()

	repo := repository.NewRepository(db, rdb, nil)
	userRepo := repository.NewUserRepository(repo)

	return userRepo, mock
}


func TestUserRepository_GetByUsername(t *testing.T) {
	userRepo, mock := setupRepository(t)

	ctx := context.Background()
	username := "test"

    // Mock the query test data
	rows := sqlmock.NewRows([]string{"id", "user_id", "username", "nickname", "password", "email", "created_at", "updated_at"}).
		AddRow(1, "123", "test", "Test", "password", "test@example.com", time.Now(), time.Now())
	mock.ExpectQuery("SELECT \\* FROM `users`").WillReturnRows(rows)

	user, err := userRepo.GetByUsername(ctx, username)
	assert.NoError(t, err)
	assert.NotNil(t, user)
	assert.Equal(t, "test", user.Username)

	assert.NoError(t, mock.ExpectationsWereMet())
}

```

The complete code can be found at: https://github.com/go-nunu/nunu-layout-advanced/blob/main/test/server/repository/user_test.go


## Test Coverage
Golang provides native support for generating test coverage reports.

```
go test -coverpkg=./internal/handler,./internal/service,./internal/repository -coverprofile=./coverage.out ./test/server/...

go tool cover -html=./coverage.out -o coverage.html
```

The above two commands will generate a coverage report file `coverage.html` in a visualized web page format, which can be directly opened in a browser.

The result looks like this:

![coverage](https://github.com/go-nunu/nunu/blob/main/.github/assets/coverage.png)

## Conclusion


Unit testing is an important development practice in a project, ensuring the correctness of the code and providing automated verification. When performing unit testing, we need to program in an interface-oriented manner and use mock objects to isolate the dependencies of the code under test. In Go language, we can use the golang/mock library to generate mock code. For repositories that depend on external data sources, we can use sqlmock and redismock to simulate the behavior of databases and caches. By using mock objects, we can control the behavior of external modules, ensuring that the code under test does not actually depend on or invoke these external modules during testing, thus achieving isolation of the code under test. This can improve the reliability, repeatability, and efficiency of the testing.